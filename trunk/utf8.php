<?php/*	Copyright (C) 2007 Babsweb.net <contact@babsweb.net>	GL::UTF8 is a part of GenericLibrairies.	GenericLibrairies is free software; you can redistribute it and/or modify	it under the terms of the GNU General Public License as published by	the Free Software Foundation; either version 3 of the License, or	(at your option) any later version.	GenericLibrairies is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	GNU General Public License for more details.	You should have received a copy of the GNU General Public License	along with this program.  If not, see <http://www.gnu.org/licenses/>.		Some of theses functions come from users contributions of PHP documentation.*//*	__Library Informations__		GenericLibrairies::UTF8 (v 1.0)		Working with UTF8 in an ASCII environment		[Dependencies]	    - PHP, version 4.0.0+	    - GenericLibrairies::Core, version 1.0.0+	    	[Important Informations]	    - See warning below	    	    - These functions are interdependent, it is risky to edit one of them		because that could produce unexpected results on others. Especially		gl_isUTF8, gl_utf8_encodeIfNotUTF8 and gl_utf8_split that are used in		almost all others.    [Constants defined]	    GL_LOADCONTROL_UTF8	    	    GL_UTF8_PAD_BOTH	    GL_UTF8_PAD_LEFT	    GL_UTF8_PAD_RIGHT	[Classes defined]	    None	[Functions defined]		gl_isUTF8			gl_utf8ize --> gl_utf8_encodeIfNotUTF8		gl_utf8_charAt		gl_utf8_chr		gl_utf8_chunk_split		gl_utf8_decodeIfUTF8		gl_utf8_encodeIfNotUTF8		gl_utf8_explode			gl_utf8_lenght --> gl_utf8_strlen		gl_utf8_ltrim		gl_utf8_ord		gl_utf8_pad		gl_utf8_reverse		gl_utf8_rtrim		gl_utf8_split		gl_utf8_strlen		gl_utf8_substr		gl_utf8_trim*//******************************************************************************|                                                                              ||                              ** WARNING! **                                  ||                                                                              ||  Do not mix strings with different encodings. This program is able to detect ||  the encoding of a string, but this detection can be done properly if        ||  multiple encodings are used. If this happens, the parties encoded in UTF-8  ||  will be encoded for a second time, considering that it was simple ASCII.    ||  So if you mix multiple encodings, or even just need to concatenate pieces,  ||  use the gl_utf8ize function on each piece to make sure the piece in         ||  question is in UTF8.                                                        ||                                                                              ||  Note that all functions of this program return a string encoded in UTF-8.   ||                                                                              | ******************************************************************************/// Start environement check //if(!defined('GL_LOADCONTROL_CORE'))	exit('<strong>GenericLibrairies::Core isn\'t loaded, include GL::Core before GL::UTF8.</strong>');// End environement check //define('GL_LOADCONTROL_UTF8', '1.0.0');define('GL_UTF8_PAD_RIGHT', 1);define('GL_UTF8_PAD_LEFT', 2);define('GL_UTF8_PAD_BOTH', 3);//// Checks if a string is UTF8-encoded//function gl_isUTF8($string){	$string = (string) $string;    return ((bool) preg_match('/./su', $string));}//// Userfriendly - Encode a string in UTF8 if it's not the case//function gl_utf8ize($str) { return gl_utf8_encodeIfNotUTF8($str); }//// Return the char at a given position//function gl_utf8_charAt($str, $position){	return gl_utf8_substr($str, $position, 1);}//// Transform an unicode code in an unicode char (thanks "anonymous")//function gl_utf8_chr($num){	$num = (int) $num;		if($num<128)		return chr($num);	if($num<2048)		return chr(($num>>6)+192).chr(($num&63)+128);	if($num<65536)		return chr(($num>>12)+224).chr((($num>>6)&63)+128).chr(($num&63)+128);	if($num<2097152)		return chr(($num>>18)+240).chr((($num>>12)&63)+128).chr((($num>>6)&63)+128) .chr(($num&63)+128);			return '';}//// Split a string into smaller chunks//function gl_utf8_chunk_split($str, $chunklen = 76, $end = "\r\n"){	//$str = gl_utf8_encodeIfNotUTF8($str);    do by gl_utf8_split, below.    $chunklen = (int) $chunklen;	$end = gl_utf8_encodeIfNotUTF8($end);	if($chunklen < 1)	    return false;    $split = gl_utf8_split($str, $chunklen);    return implode($end, $split);}//// Decode a string from UTF8 if the string is in UTF8//function gl_utf8_decodeIfUTF8($str){	$str = (string) $str;    if(gl_isUTF8($str))        $str = utf8_decode($str);	return $str;}//// Encode a string in UTF8 if it's not the case//function gl_utf8_encodeIfNotUTF8($str){    $str = (string) $str;    if(!gl_isUTF8($str))        $str = utf8_encode($str);        	return $str;}//// Split a string by string//function gl_utf8_explode($delimiter, $string, $limit = 0){    $string = gl_utf8_split($string);    $delimiter = gl_utf8_encodeIfNotUTF8($delimiter);    $limit = (int) $limit;        $result = array('');    $currentIndex = 0;        $offset = -1;        /*foreach($string as $char)    {        if($char == )    }*/}//// Alias - Get string lenght//function gl_utf8_lenght($str) { return gl_utf8_strlen($str); }//// Strip whitespace (or other characters) from the beginning of a string//function gl_utf8_ltrim($str, $charlist = " \t\n\r\0\x0B"){    $str = gl_utf8_split($str);    $charlist = gl_utf8_split($charlist);    $cutAt = 0;    foreach($str as $char)    {        if(in_array($char, $charlist))            $cutAt++;		else		    break;    }    return implode('', gl_utf8_split(gl_utf8_substr(implode('', $str), $cutAt)));}//// Return Unicode value of character (thanks "steph at zend dot com")//function gl_utf8_ord($ch){	$ch = (string) $ch;	$n = ord($ch[0]);    if ($n < 128) {        return $n; // no conversion required    }    if ($n < 192 || $n > 253) {        return false; // bad first byte || out of range    }    $arr = array(1 => 192, // byte position => range from                 2 => 224,                 3 => 240,                 4 => 248,                 5 => 252);    foreach ($arr as $key => $val) {        if ($n >= $val) { // add byte to the 'char' array            $char[] = ord($ch{$key}) - 128;            $range  = $val;        } else {            break; // save some e-trees        }    }    $retval = ($n - $range) * pow(64, sizeof($char));    foreach ($char as $key => $val) {        $pow = sizeof($char) - ($key + 1); // invert key        $retval += $val * pow(64, $pow);   // dark magic    }    return $retval;}//// Pad a string to a certain length with another string//function gl_utf8_pad($str, $pad_length, $pad_string = ' ', $pad_type = GL_UTF8_PAD_RIGHT){    $str = gl_utf8_encodeIfNotUTF8($str);    $pad_length = (int) $pad_length;    $pad_string = gl_utf8_encodeIfNotUTF8($pad_string);    if(!in_array($pad_type, array(GL_UTF8_PAD_RIGHT, GL_UTF8_PAD_LEFT, GL_UTF8_PAD_BOTH), true))        $pad_type = GL_UTF8_PAD_RIGHT;	if(gl_utf8_strlen($str) == $pad_length)	    return $str;	    	if(gl_utf8_strlen($str) > $pad_length)	    return gl_utf8_substr($str, 0, $pad_length);	    	switch($pad_type)	{	    case GL_UTF8_PAD_RIGHT:	        $result = $str;	        $offset = 0;	        	        while(gl_utf8_strlen($result) < $pad_length)	        {	            $result .= gl_utf8_charAt($pad_string, $offset);	            	            $offset++;	            if($offset >= gl_utf8_strlen($pad_string))	                $offset = 0;	        }	        	        return $result;	                case GL_UTF8_PAD_LEFT:	        return gl_utf8_reverse(gl_utf8_pad(gl_utf8_reverse($str), $pad_length, gl_utf8_reverse($pad_string), $pad_type = GL_UTF8_PAD_RIGHT));		case GL_UTF8_PAD_BOTH:		    $leftChars = floor(($pad_length-gl_utf8_strlen($str))/2);		    $rightChars = ceil(($pad_length-gl_utf8_strlen($str))/2);		    			return gl_utf8_pad('', $leftChars, $pad_string).$str.gl_utf8_pad('', $rightChars, $pad_string);	}}//// Return a string with chars in reverse order//function gl_utf8_reverse($str){	return implode('', array_reverse(gl_utf8_split($str)));}//// Strip whitespace (or other characters) from the end of a string//function gl_utf8_rtrim($str, $charlist = " \t\n\r\0\x0B"){    $str = array_reverse(gl_utf8_split($str));    $charlist = gl_utf8_split($charlist);        $cutAt = 0;        foreach($str as $char)    {        if(in_array($char, $charlist))            $cutAt++;		else		    break;    }        return implode('', array_reverse(gl_utf8_split(gl_utf8_substr(implode('', $str), $cutAt))));}//// Convert a string to an array//function gl_utf8_split($str, $split_length = 1){    $split_length = (int) $split_length;    if($split_length < 1)	    return false;	    	$str = gl_utf8_encodeIfNotUTF8($str);	preg_match_all('/.{1,'.((int) $split_length).'}/su', $str, $pregged);    return $pregged[0];}//// Get string length//function gl_utf8_strlen($str){	$split = gl_utf8_split($str);	return count($split);}//// UTF8 complilant version of substr()//function gl_utf8_substr($str, $start, $length = false){	$split = gl_utf8_split($str);	$start = (int) $start;	$length = (int) $length;	if($length === false)	    $result = implode('', array_slice($split, $start));	else	    $result = implode('', array_slice($split, $start, $length));	    	return $result;}//// Strip whitespace (or other characters) from the beginning and end of a string//function gl_utf8_trim($str, $charlist = " \t\n\r\0\x0B"){    return gl_utf8_ltrim(gl_utf8_rtrim($str, $charlist), $charlist);}